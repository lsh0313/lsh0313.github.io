# 温故而知新之JavaScript 基础语法篇
## 一.JS基础来源认知

   *JavaScript*是一种解释性脚本语言，主要用来向*HTML*页面添加交互行为。完整的*JavaScript*分为三个部分：*ECMAScript、BOM、DOM*。其中*ECMAScript*，描述了该语言的语法和基本对象。*BOM*是指浏览器对象模型，描述与浏览器进行交互的方法和接口。*DOM*是指文档对象模型，描述处理网页内容的方法和接口。本文将要介绍的，就是*ECMAScript*基础语法部分。
## 二.基础语法之变量
### 1.变量的声明
  * *JavaScript*是一门弱类型语言，变量的声明和定义只用一个 **var** 进行标注，在这里需要注意的是，变量的**声明提升**问题。
  * 在 *js*语法规则里，我们在对一个变量进行声明或者定义后，变量的声明或默认提升到当前作用域的最前端。这其实是因为一段代码运行之前要引擎会对代码进行编译，也就是所谓的编译阶段，此时会将代码中的所有变量先进行声明，方便变量在代码执行阶段时对变量进行调用。通常声明提升会造成变量值出现偏差，如下行代码，会打印undefined而不是报错。
  
         console.log(a);
         var a='hello world';
     
### 2.变量的数据类型
##### JavaScript中变量的数据类型分为简单数据类型和复杂数据类型两类
* （1）String：字符串类型,通常是由一个或多个带引号的字符串组成
* （2）Number：数字类型，整数或浮点数
* （3）Boolean：布尔类型，值只有true和false两种
* （4）Undefined：变量只有声明没有赋值
* （5）Null：变量声明了，且值为空。其实这是一个js当初设计上的一个错误，但是后来被沿用了下来，可以理解为NUll是一个指向空对象的指针

** 延伸： ** 

     console.log(undefined == null);//true     
     console.log(undefined === null);//false


* 此时undefined的值为空的 null的值也是空 系统默认值相同。 如果是 === 因为他们的类型不同 所以返回的结果是false.
   
* 任何时候都没有必要把一个变量指为undefined，但是如果在程序当中一个变量暂时不需要赋值，习惯上可以先给个null而不是undefined.
   
* undefined null都表示假。在js中，非0即为真。0代表假


** 以上五种为基本数据类型，数据的值比较单一，数据存储地址采用顺序存储方式，查找修改比较方便 **

* （1）Array：数组类型，数组类型是特殊的对象数据类型，但因为用法特殊，在这里单独划为一类
* （2）Object：对象数据类型
* （3）Function：用{}包裹起来的代码块



** Array和Object被称为复杂数据类型，数据类型可以是基本数据，也可以是复杂数据。数值和地址采用链式存储方式。值和址分离，当我们对复杂数据类型赋值时，其实是将地址赋值。修改数据时，会直接修改原来数据上的值，小心值会改变。 **
### 3.数据的类型转化（显式和隐式）

** 提到数据的类型，数据类型的转化就是另一个不得不提知识点 **

** 显式转换：** 手动给数据类型转换，要用到以下方法

* Number() ：转换成数字类型
* String()：转换成字符串类型
* toString(8) 这里的8代表进制 用于数字转化字符串
* Boolean()：转换成布尔类型，null和undefined都能解析成布尔类型的值
* parseInt(); 取整 ，从左到右进行数字的提取，遇到非数字返回，如果最开始就提取不到数字，返回NaN
* parseFloat();取浮点数 从左到右进行数字的提取，遇到非数字返回，如果最开始就提取不到数字，返回NaN

** 隐式转换：** 计算机在进行数据运算的时候，会默认把能转成相同数据类型的不同数据隐式转换成相同的数据类型，再进行运算，需要注意的是，字符串的优先级要高于数字，当一个String和Number进行+运算时，会优先将Number转换成String再进行字符串拼接，示例如下：
      
      var a = 10;
      var b = "10";
      console.log(typeof(a + ""));//string  数字+字符串 得到字符串
      console.log(typeof + b); //Number +字符串 得到数字类型 +相当于取正号
      
   
   **typeof()方法：** 可以判断变量的类型   
   **is NaN()：** （Not a Number不是一个数字,数字类型的一种,与任何值都不想等，包括它自己 ）可以判断变量是否可以以转化为数字(NaN Not a Number ） 
     
  这个方法可以判断一个变量是否可以转化为数字，如果可以转化为数字 返回：false。如果不可以转化为数字 返回：true。本文在此举几个经常会用到is NaN()方法的情况
  
      console.log(isNaN("abc"));//true
      console.log(isNaN(true));//false
      console.log(isNaN(undefined));//true
      console.log(isNaN(null));//false
      console.log(isNaN("123"));//false
      console.log(Number(false)); //0
      console.log(Number(true)); //1
      console.log(Number(undefined));//NaN
      console.log(Number(null));// 0
      console.log(parseInt(""));//NaN

### 4.变量的作用域
  想要知道什么是变量的作用域，首先要知道什么是**作用域链**。

>作用域链：作用域链是描述一种路径的术语,沿着该路径可以确定变量的值。相同的变量名，会产生一个作用域链，访问该变量名称的时候，会首先找本层是否有该变量，如果没有去父层找，最终找到全局变量为止，如果全局变量也没有，那么会报错

js是一门不严谨的语言,在js里面有全局作用域,函数作用域，没有块级作用域。比如在for循环中定义i，出了for循环一样能调用i


     for(var i = 0;i < 10; i++){
      console.log(i);//1-9
      }
     console.log(i);//10
     console.log(window.i);//10



* **局部变量：** js中的局部变量是指只能在局部地区使用，定义在{}之内的变量，就是局部变量，出了{}就不能使用了

* **全局变量：**通常意义上是指Windows下面的变量

**重要提示：**  

* ** 定义一个变量必须加 var ， 一旦一个变量定义的时候没有加var ， 则这个变量就是全局变量 **

* **局部变量和全局变量重名时，局部变量优先级高**



### 5.变量的运算

**运算符** 

* 算术运算符 + - * /  %
* 比较运算符 > < = 结果都是布尔值
* 赋值运算符 =   +=  -=  *=   /= 
* 逻辑运算符 &&  ||  ! （与 或 非）
* 单目运算符 ++ --  
* 三目运算符  ? :   var c= a>b?a:b
* 判断相等 ：==（值等） ===（值和类型全等）
 
**逻辑运算符的短路现象问题**
 
* 三目运算符短路问题: 至少三个数参与
      
        var result = 5>3 ? 5:3;  
        
    ?左边是条件 ?右边是两种结果。   ：左边的是条件成立时的取值，：右边是不成立的取值。
* 逻辑短路现象

     且的短路现象   &&  左边如果为假 右边的运算根本不会管。如果左边为真，右边才会执行。
    
     或的短路现象   ||  左边如果为真 右边根本不会管。如果左边为假，右边才会执行。

## 三.基础语法之结构
**代码中常见的结构有三种，顺序结构，分支结构，循环结构**

### 1.顺序结构（从左到右，从上到下）
### 2.分支结构：可选择性的执行代码
* if  else 语句：常用于两种分支结构，也可用于多种分支

      1. if(){
          分支一；
         }
      
      2. if(){
         分支一；
         }else{
         分支二；
         }
      3. if(条件){
           分支一；
          }else if(){
           分支二；
          }else{
           分支三；
         }
* switch语句：常用于多种分支结构,switch循环体里面如果没有break跳出，case会顺序执行直到结束
  
      switch(条件){
        case:分支一;break;//break用来跳出switch结构
        case:分支二;break;
        default://默认执行这里;break；
       }
   
* 循环结构：可循环性的执行代码 while、 do while、 for


     * while：未知有限次数的循环
       
          while(条件){
              循环体;
              循环增量；//作用:跳出循环
              }
              
     * do{}While：很少用，几乎可以忽略不用
           
          do{
             循环体;
             循环增量；//作用:跳出循环
            }while(条件);
            
     * for循环：可知有限次数的循环

          for(var i=1;i<=100;i++){
           console.log(i);//循环体
          }
          

**循环必须要有的东西**

* 循环初始值
* 循环条件
* 循环体
* 循环增量


** 跳出循环的关键字 **

*  break;用来跳出switch语句，或者用于跳循环
*  continue -- 作用只有一个，用在循环当中，用于结束“当次”循环




## 四.基础语法之函数
### 1.函数的定义
  **函数**是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数本质上也是一种数据类型，可以看做是对象类型object。通俗意义上讲，函数就是包裹在花括号{}中的代码块，前面使用了关键词 function 

* 函数的几个关键部分：
     * 函数关键字 function
     * 函数名 （不必有）
     * 函数参数 （不必有）
     * 函数体  （必须）
     * 函数返回值 （不必有）

### 2.函数的分类
* 按照有无函数名分类 分为有名函数和匿名函数。
    
      function A(){} //有名函数
      function (){}  //匿名函数 匿名函数与闭包有关
      (function(){
         console.log("我是匿名函数")
        })();
* 按照函数返回值分类

      function B(){} //无返回值
      function C(){  
        return "a";  //有返回值
      }
      
* 按照参数类型分类 分为有参和无参
      
      function B(a){ //有参
          console.log(a);
      } 
      function C(){  //无参
          console.log(123);
      }



* 形参和实参的概念

     * **形式参数和实际参数；简称形参和实参**

     * **函数定义时候小括号里面的参数叫形式参数，函数调用的时候小括号里面的参数叫实际参数**

### 3.函数的使用
**函数的使用分为三个阶段**

* 函数的声明
* 函数的定义
* 函数的调用

**函数的声明**

 在js里面函数的声明由系统自动实现，不需要我们显式声明。我们需要注意的是函数的声明提升。
 
函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（跟变量声明提升非常类似）。正是因为这个特征，把函数声明放在调用它的语句后面。如下面例子，最终的输出结果却是2，

        var fn = function(){
           console.log(2);
         }
        function fn (){
           console.log(1);
         }
        fn();//2


这个例子就涉及到了函数声明提升。正如前面说到的函数声明提升，函数声明function fn(){}的声明定义会被提前到顶部。而函数表达式var fn = function(){}中，fn作为一个变量，虽然它也也会声明提升到最顶，但变量的赋值（函数赋值给了变量）依然保留在原来的位置。所以在编译过程中，fn()调用的是最后赋值的函数，打印的也就是2了。

** 函数的定义 **

一般的，我们使用function 关键字对函数代码块进行函数定义，函数代码块默认是Object类型数据。

** 函数的使用 **

  * **函数的回调：**
A函数当做B函数的参数传递到B函数，在B函数内部一定的条件下触发A函数，就叫函数回调

  
      function fun1(){
        console.log("fun1");
      }
      function fun2(obj1){
         if(5>3){
           obj1();
        }
      }
      fun2(fun1);
      
*  **闭包**  函数内部能够作为返回值的可以调用函数内部变量的代码段


      * **作用:联系函数内部和函数外部的桥梁；常驻内存。**

      * **优点：保值作用:避免变量被污染;常驻内存。** 

下面是闭包的使用举例

     //要求点击哪个div，弹框显示当前是第几个div  这是不使用闭包的情况
     var divArray = document.getElementsByTagName("div");
     for(var i=0;i<divArray.length;i++){
         function wahaha(num){
               divArray[i].onclick = function(){
                    alert(num);
                    //alert(divArray.indexOf(this));不能用，因为divArray 并不是一个真正的数组，是类数组
               }
               return
         }
         wahaha(i);
     }
    // 下面是匿名闭包的使用
     var divArray = document.getElementsByTagName("div");
        for(var i=0;i<divArray.length;i++){
           (function (num){
               divArray[i].onclick = function(){
                  alert(num);  
              }
        })(i);
     }
     
     
*  **函数的递归调用**程序调用自身的编程技巧称为递归


递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

       function add(a){ 
         if(a>0){
           return a + add(a-1);
         }else{
           return 0;
         }
      }
     console.log(add(10)) ;//求1+2+3..+10的和
     
     
** 关于函数的几点常考问题 **

* 函数碰到return就结束，return之后的代码不会得到执行
* return 后面可以不返回具体的内容，这时候return主要用来结束函数
* 函数可以嵌套定义
 


